## 宏（理解为函数，封装一系列动作）
1. 开始录制 qa (a是寄存器名字，也可是别的)
2. 结束录制  q
3. 查看录制好的宏 :reg a
4. 使用 @a (a是寄存器的名字) 
5. 调用最后一次执行的宏   @@  对于某个宏要连续调用时，极有用
6. 重复执行 数字+圈+寄存器   10@a
(扩展：)
7. 安全机制 降低心智负担
  1. 报错就停：pattern not found
  2. 应用：替换多个时，不需精确知道个数，写大一点（比如50）替换完了报错就会停止
(录制好了复杂命令后需要修改)
8. 追加 qA （比如寄存器a => A）qQ,qI等等。。。
9. 修改一个已知的宏
    1. 就是修改寄存器里的内容
    2. 取出来
      1. "ap (a是寄存器名) p:复制出来 ":获取寄存器的值
      2. :put a
    3. 修改 "ayw or "ayy 粘贴进去   (a是寄存器名)     (yy:本行内容复制 w:单词
    4. bug: vscode里vim插件改完后使用@[寄存器名] 不生效
10. 技巧
  1. 先规范好光标的位置
  2. 移动的时候使用相对位置
    1. 比如w e textObject / f t 都可以
    2. 但是 jkhl时绝对位置
  

## 练习
1) one
2. two
3. three
4. four
5. five
6. six
7. seven
8. eight
需求 1.改成1) + 单词首字母大写
0回到行首
f.回车 使用相对位置方法找到.(考虑到10这种两位数不使用l等绝对位置)
r) 替换成）
w来到下一个单词首
~ 大小写替换
j 下一行
q 结束录制

